% STD
loop:
	;; Stop if there is no more input
	!ICO ? NIP <- #HLT
	;; Call read_and_reverse with word_buffer as destination
	;; pointer. The function returns the length of the word
	;; in RES.
	
	STT <- #word_buffer
	NIP <- #read_and_reverse

	

	;; Print the reversed word

	;; Temporary variable with a pointer to the word
	STT <- #word_buffer
	DBG <- *ST0

print_loop:
	;; Stop when all characters are printed
	!RES ? NIP <- #print_done

	;; Print character
	DBG <- *ST0
	PRN <- *ST0

	;; Increment pointer
	ST0 <- INC <- ST0

	;; Decrement counter
	RES <- DEC <- RES

	;; Loop
	NIP <- #print_loop
print_done:
	;; Clean up the stack and continue reading
	RES <- STT
	NIP <- #loop

	;; word buffer + separator
word_buffer:
	0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
	0

;;;
;;; Read one word from the input and reverses it.
;;;
;;; The function takes one argument, the destination buffer for the
;;; reversed string.
;;;
;;; The reversed string includes the separator character at the end.
;;;
read_and_reverse:
	;; Get destination pointer from stack
	RES <- STT

	;; Save return address on the stack
	STT <- PIP
	;; Allocate space for 3 variables and a temp buffer
	ALX <- STP
	ALY <- #19
	STP <- DIF

	;; Use ST0 as a pointer to the buffer
	ST0 <- INC <- INC <- INC <- STP

	;; Use ST1 as counter, starting at 0
	ST1 <- #0

	;; Use ST2 as the destination pointer
	ST2 <- RES

read_loop:
	;; Set RES to newline in case there is no more input
	RES <- #10

	;; Stop if there is no more input
	!ICO ? NIP <- #read_done

	;; Read the next character
	RES <- IDA

	;; Stop if it was a space, tab or newline
	ALX <- RES
	DBG <- RES
	ALY <- #' '
	EQU ? NIP <- #read_done
	ALY <- #9
	EQU ? NIP <- #read_done
	ALY <- #10
	EQU ? NIP <- #read_done

	;; If the 16 character limit has been exceeded, print an error
	;; message and stop
	ALX <- ST1
	ALY <- #16
	UGT ? NIP <- #read_error

	;; Write character to buffer
	*ST0 <- RES

	;; Increment pointer and counter
	ST0 <- INC <- ST0
	ST1 <- INC <- ST1

	;; Continue reading
	NIP <- #read_loop

read_done:
	;; Store the length in ALX
	ALX <- ST1

	;; Copy the word to the destination, reading backwards from
	;; the temp buffer
	ST0 <- DEC <- ST0
read_reverse_loop:
	;; Stop if the counter reaches 0
	!ALX ? NIP <- #read_reverse_done

	;; Copy character
	*ST2 <- *ST0
	DBG <- *ST0

	;; Decrement source pointer
	ST0 <- DEC <- ST0

	;; Decrement counter
	ALX <- DEC <- ALX

	;; Increment dest pointer
	ST2 <- INC <- ST2

	;; Continue copying
	NIP <- #read_reverse_loop

read_reverse_done:
	;; Write the separator character at the end
	*ST2 <- RES
	DBG <- RES

	;; Set the return value to the length of the word plus the
	;; space or newline
	RES <- INC <- ST1

read_return:
	;; Clean up the stack
	ALX <- STP
	ALY <- #19
	STP <- SUM

	;; Return
	
	DBG <- ST0
	
	NIP <- STT

read_error:
	;; Print error message and stop
	RES <- #read_error_string
read_error_loop:
	!*RES ? NIP <- #HLT
	PRN <- *RES
	RES <- INC <- RES
	NIP <- #read_error_loop

read_error_string:
	"ERROR: Maximum word length is 16 characters",10,0

-----
% STD
	ALX <- #$F0E1
	ALY <- #$9d15
	DBG <- SUM
	NIP <- #HLT

string: "te","st", 10, 0
ptr: string