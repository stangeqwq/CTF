from mpmath import mp

n = 1504669465049250683772825812578432054507293469234421835013894405310029960001983693956912395839709925438318274076100369116441789151651472045481303645596451178044586947308741326342766946348630525172225455603087171717275879906781697990672417080309828718603899890408758061554793354470946237190153046132595139051833787905084525716653409952939965245932629241867891105816295312963551089357342449126371563191942303757697572037235418723425388339389144253372697659489780008584869576092272222910562814998683399481883646227829886163589601081060863166903096435784100163915678274553319845314634193005315230701522142083632691208361739899372423774622550914730653670856567925991737570190700269083750650059188495925847590358041692543397415444779391909829587672451139072901892332418440718339037451719206793643432918776943522136979576087474253202699170303465845463979782634173216861141355335128763721879090387732568316702463122261502225660041393
# Define the polynomial function
def f(x):
    return a*x**3 + b*x**2 + c*x + d

# Define the derivative of the polynomial function (for Newton-Raphson method)
def df(x):
    return 3*a*x**2 + 2*b*x + c

for N in range(100):
    # Set the precision (number of decimal places)
    mp.dps = 100  # Increase this value for higher precision

    # Define the coefficients of the cubic polynomial ax^3 + bx^2 + cx + d = 0
    a = mp.mpf("1")  # Convert to mpf for arbitrary-precision
    b = mp.mpf(f"{N + 1/2}")
    c = mp.mpf("0")
    d = mp.mpf("752334732524625341886412906289216027253646734617210917506947202655014980000991846978456197919854962719159137038050184558220894575825736022740651822798225589022293473654370663171383473174315262586112727801543585858637939953390848995336208540154914359301949945204379030777396677235473118595076523066297569525916893952542262858326704976469982622966314620933945552908147656481775544678671224563185781595971151878848786018617709361712694169694572126686348829744890004292434788046136111455281407499341699740941823113914943081794800540530431583451548217892050081957839137276659922657317096502657615350761071041816345604180869949686211887311275457365326835428283962995868785095350134541875325029594247962923795179020846271698707722389695954914793836225569536450946166209220359169518725859603396821716459388471761068489788043737126601349585151732922731989891317086608430570677667564381860939545193866284158351231561130751112830020696")

    # Initial guess for the root (you can choose any starting point)
    x0 = mp.mpf("90950209550247323506728480257318086288353001119862377453664234832085215787500150478717844010146998399433149540416925596859013049294728602488485851683213319234090536594116047838260532741368711028912943810350437484766109508819972612653477528378857820645836010739391410100255915340640611251801380868113972203064")  # Start with x = 1

    # Apply Newton-Raphson iteration to approximate the root
    max_iterations = 1000
    tolerance = mp.mpf("1e-30")  # Adjust tolerance as needed
    x = x0
    for i in range(max_iterations):
        dx = -f(x) / df(x)  # Compute the Newton-Raphson step
        x += dx
        if abs(dx) < tolerance:
            break
    x = abs(x)
    # The value of x should now be close to a root of the polynomial
    print("Approximate root:", x)
    print(f"n - guess: {n - x*x*(2*x + 1 + 2*N)}")
    print(n)
    print(x*x*(2*x + 1 + 2*N))